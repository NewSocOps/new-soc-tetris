<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>AI vs AI Tetris (PyScript)</title>
<link rel="stylesheet" href="https://pyscript.net/releases/2024.11.1/core.css" />
<script type="module" src="https://pyscript.net/releases/2024.11.1/core.js"></script>
<style>
body {
  font-family: Arial, sans-serif;
  background-color: #111;
  color: #e2e2e2;
  margin: 0;
  padding: 32px 24px;
}

h1 {
  margin-top: 0;
  letter-spacing: 1px;
}

#controls {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
}

button {
  padding: 8px 16px;
  background-color: #1e88e5;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.95rem;
}

button:hover:not(:disabled) {
  background-color: #1976d2;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.secondary {
  background-color: #424242;
}

button.secondary:hover:not(:disabled) {
  background-color: #616161;
}

button.danger {
  background-color: #d32f2f;
}

button.danger:hover:not(:disabled) {
  background-color: #c62828;
}

label {
  font-size: 0.9rem;
}

input[type="range"] {
  width: 160px;
}

#status {
  margin: 12px 0 24px 0;
  font-size: 1rem;
}

.boards {
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
}

.board {
  min-width: 240px;
}

.board h2 {
  margin-bottom: 8px;
  font-size: 1.1rem;
}

pre {
  background-color: #000;
  color: #39ff14;
  padding: 12px;
  line-height: 1.1;
  border-radius: 4px;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.15);
  overflow-x: auto;
}

#bank {
  margin-top: 24px;
}

footer {
  margin-top: 36px;
  font-size: 0.8rem;
  color: #8c8c8c;
}

.tournament-section {
  margin-top: 32px;
  padding: 20px;
  background-color: #1a1a1a;
  border-radius: 8px;
}

.tournament-section h2 {
  margin-top: 0;
  margin-bottom: 16px;
}

.tournament-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.tournament-controls label {
  font-size: 0.9rem;
}

.tournament-controls input[type="number"] {
  width: 60px;
  padding: 4px 8px;
  background-color: #2a2a2a;
  color: #e2e2e2;
  border: 1px solid #444;
  border-radius: 4px;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
}

table th, table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #333;
}

table th {
  background-color: #2a2a2a;
  font-weight: 600;
}

table tr:hover {
  background-color: #252525;
}

#tournament-results {
  display: none;
}

#tournament-results.visible {
  display: block;
}
</style>
</head>
<body>
<h1>AI vs AI Tetris (PyScript)</h1>
<div id="controls">
  <button id="start">‚ñ∂Ô∏è Start Match</button>
  <button id="pause" disabled>‚è∏Ô∏è Pause</button>
  <button id="resume" disabled>‚ñ∂Ô∏è Resume</button>
  <button id="step" disabled>‚è≠Ô∏è Step</button>
  <button id="restart" class="secondary" disabled>üîÑ Restart</button>
  <label for="speed">Speed:</label>
  <input id="speed" type="range" min="50" max="600" value="150" step="10" />
  <span id="speed-value">150 ms</span>
</div>
<div id="status">Press "Start Match" to begin the simulation.</div>
<div class="boards">
  <div class="board">
    <h2 id="ai1-name">AI-1</h2>
    <pre id="board1"></pre>
  </div>
  <div class="board">
    <h2 id="ai2-name">AI-2</h2>
    <pre id="board2"></pre>
  </div>
</div>
<pre id="bank"></pre>

<div class="tournament-section">
  <h2>üèÜ Tournament Mode</h2>
  <div class="tournament-controls">
    <label for="num-matches">Number of matches:</label>
    <input id="num-matches" type="number" min="1" max="50" value="5" />
    <button id="start-tournament">üéØ Run Tournament</button>
    <button id="clear-tournament" class="secondary">üóëÔ∏è Clear Results</button>
  </div>
  <div id="tournament-results">
    <h3>Results</h3>
    <table id="tournament-table">
      <thead>
        <tr>
          <th>Match #</th>
          <th>Winner</th>
          <th>AI-1 Score</th>
          <th>AI-2 Score</th>
          <th>Turns</th>
          <th>Reason</th>
        </tr>
      </thead>
      <tbody id="tournament-tbody"></tbody>
    </table>
    <div style="margin-top: 16px; padding: 12px; background-color: #2a2a2a; border-radius: 4px;">
      <strong>Summary:</strong>
      <div id="tournament-summary"></div>
    </div>
  </div>
</div>

<footer>
  Powered by PyScript. Runs entirely in the browser without servers or binaries.
</footer>
<py-config>
  packages = []
</py-config>
<py-script>
import asyncio
import random
import time
from js import document
from pyodide.ffi import create_proxy

# --- Core data structures ----------------------------------------------------

SHAPES = {
    "I": [[1, 1, 1, 1]],
    "O": [[1, 1], [1, 1]],
    "T": [[0, 1, 0], [1, 1, 1]],
    "S": [[0, 1, 1], [1, 1, 0]],
    "Z": [[1, 1, 0], [0, 1, 1]],
    "L": [[1, 0], [1, 0], [1, 1]],
    "J": [[0, 1], [0, 1], [1, 1]],
}

TETROMINO_TYPES = list(SHAPES.keys())


def clone_shape(shape):
    return [row[:] for row in shape]


class Tetromino:
    def __init__(self, shape_type: str):
        self.type = shape_type
        self.shape = clone_shape(SHAPES[shape_type])
        self.rotation = 0

    def rotate(self):
        rotated = [list(row) for row in zip(*self.shape[::-1])]
        self.shape = rotated
        self.rotation = (self.rotation + 1) % 4

    def get_width(self):
        return len(self.shape[0]) if self.shape else 0

    def get_height(self):
        return len(self.shape)


class GameBoard:
    def __init__(self, width: int = 10, height: int = 20):
        self.width = width
        self.height = height
        self.grid = [[0 for _ in range(width)] for _ in range(height)]
        self.score = 0
        self.lines_cleared = 0
        self.game_over = False

    def can_place(self, piece: Tetromino, x: int, y: int) -> bool:
        for row_idx, row in enumerate(piece.shape):
            for col_idx, cell in enumerate(row):
                if not cell:
                    continue
                board_y = y + row_idx
                board_x = x + col_idx
                if board_x < 0 or board_x >= self.width:
                    return False
                if board_y < 0 or board_y >= self.height:
                    return False
                if self.grid[board_y][board_x]:
                    return False
        return True

    def place_piece(self, piece: Tetromino, x: int, y: int):
        for row_idx, row in enumerate(piece.shape):
            for col_idx, cell in enumerate(row):
                if cell:
                    board_y = y + row_idx
                    board_x = x + col_idx
                    if 0 <= board_y < self.height and 0 <= board_x < self.width:
                        self.grid[board_y][board_x] = 1

    def clear_lines(self) -> int:
        completed = [index for index, row in enumerate(self.grid) if all(row)]
        for idx in completed:
            del self.grid[idx]
            self.grid.insert(0, [0 for _ in range(self.width)])
        cleared = len(completed)
        if cleared:
            self.lines_cleared += cleared
            score_table = {1: 100, 2: 300, 3: 500, 4: 800}
            self.score += score_table.get(cleared, cleared * 100)
        return cleared

    def add_garbage_lines(self, num_lines: int):
        for _ in range(num_lines):
            self.grid.pop(0)
            garbage = [1 for _ in range(self.width)]
            hole = random.randint(0, self.width - 1)
            garbage[hole] = 0
            self.grid.append(garbage)

    def is_game_over(self) -> bool:
        return any(self.grid[0])

    def get_height_map(self):
        heights = []
        for x in range(self.width):
            column_height = 0
            for y in range(self.height):
                if self.grid[y][x]:
                    column_height = self.height - y
                    break
            heights.append(column_height)
        return heights

    def get_max_height(self):
        heights = self.get_height_map()
        return max(heights) if heights else 0

    def to_string(self) -> str:
        lines = ["+" + "-" * self.width + "+"]
        for row in self.grid:
            line = "|" + "".join("#" if cell else " " for cell in row) + "|"
            lines.append(line)
        lines.append("+" + "-" * self.width + "+")
        return "\n".join(lines)


class FigureBank:
    def __init__(self, initial_count: int = 15):
        self.bank = {piece: initial_count for piece in TETROMINO_TYPES}

    def get_piece(self, piece_type: str) -> bool:
        if piece_type not in self.bank:
            return False
        if self.bank[piece_type] > 0:
            self.bank[piece_type] -= 1
            return True
        return False

    def is_available(self, piece_type: str) -> bool:
        return piece_type in self.bank and self.bank[piece_type] > 0

    def get_available_pieces(self):
        return [piece for piece in TETROMINO_TYPES if self.bank[piece] > 0]

    def is_empty(self) -> bool:
        return all(count == 0 for count in self.bank.values())

    def get_random_available(self) -> str | None:
        available = self.get_available_pieces()
        if available:
            return random.choice(available)
        return None

    def get_state(self):
        return self.bank.copy()


class AIAgent:
    def __init__(self, name: str, strategy: str = "greedy"):
        self.name = name
        self.strategy = strategy
        self.decision_times = []

    def decide_placement(self, board: GameBoard, piece: Tetromino):
        start_time = time.time()
        best_position = None
        best_score = float("-inf")
        for rotation in range(4):
            piece_copy = Tetromino(piece.type)
            for _ in range(rotation):
                piece_copy.rotate()
            for x in range(board.width - piece_copy.get_width() + 1):
                y = 0
                while y < board.height and board.can_place(piece_copy, x, y):
                    y += 1
                y -= 1
                if y >= 0 and board.can_place(piece_copy, x, y):
                    score = self._evaluate_position(board, piece_copy, x, y)
                    if score > best_score:
                        best_score = score
                        best_position = (x, y, rotation)
        decision_time = time.time() - start_time
        self.decision_times.append(decision_time)
        if best_position:
            return best_position
        return (board.width // 2, 0, 0)

    def _evaluate_position(self, board: GameBoard, piece: Tetromino, x: int, y: int) -> float:
        test_board = GameBoard(board.width, board.height)
        test_board.grid = [row[:] for row in board.grid]
        test_board.place_piece(piece, x, y)
        max_height = test_board.get_max_height()
        heights = test_board.get_height_map()
        bumpiness = sum(abs(heights[i] - heights[i + 1]) for i in range(len(heights) - 1))
        holes = 0
        for col_x in range(board.width):
            found_block = False
            for row_y in range(board.height):
                if test_board.grid[row_y][col_x]:
                    found_block = True
                elif found_block:
                    holes += 1
        if self.strategy == "greedy":
            score = -max_height * 2 - holes * 5 - bumpiness
        elif self.strategy == "defensive":
            score = -max_height * 3 - holes * 10 - bumpiness * 2
        elif self.strategy == "aggressive":
            lines_cleared = self._count_potential_lines(test_board)
            score = lines_cleared * 100 - max_height - holes * 3
        else:
            score = -max_height - holes
        return score

    def _count_potential_lines(self, board: GameBoard) -> int:
        return sum(1 for row in board.grid if all(row))

    def choose_attack_piece(self, bank: FigureBank):
        available = bank.get_available_pieces()
        if not available:
            return None
        if self.strategy == "aggressive":
            difficult = [p for p in ["T", "L", "J"] if p in available]
            if difficult:
                return random.choice(difficult)
        elif self.strategy == "defensive":
            easy = [p for p in ["I", "O"] if p in available]
            if easy:
                return random.choice(easy)
        return random.choice(available)


class Arena:
    def __init__(self, ai1: AIAgent, ai2: AIAgent, bank: FigureBank, max_turns: int = 360):
        self.ai1 = ai1
        self.ai2 = ai2
        self.board1 = GameBoard()
        self.board2 = GameBoard()
        self.bank = bank
        self.max_turns = max_turns
        self.turn = 0
        self.current_piece_ai1 = self._get_next_piece()
        self.current_piece_ai2 = self._get_next_piece()
        self.garbage_queue_ai1 = 0
        self.garbage_queue_ai2 = 0

    def _get_next_piece(self) -> str:
        piece_type = self.bank.get_random_available()
        if piece_type:
            self.bank.get_piece(piece_type)
            return piece_type
        return random.choice(TETROMINO_TYPES)

    def play_turn(self, ai: AIAgent, board: GameBoard, piece_type: str):
        piece = Tetromino(piece_type)
        x, y, rotations = ai.decide_placement(board, piece)
        for _ in range(rotations):
            piece.rotate()
        if board.can_place(piece, x, y):
            board.place_piece(piece, x, y)
        else:
            board.game_over = True
            return 0, 0.0, None
        lines_cleared = board.clear_lines()
        attack_piece = None
        if lines_cleared > 0:
            attack_piece = ai.choose_attack_piece(self.bank)
        decision_time = ai.decision_times[-1] if ai.decision_times else 0.0
        return lines_cleared, decision_time, attack_piece

    def _result_state(self, finished: bool, winner: str | None, reason: str):
        return {
            "finished": finished,
            "winner": winner,
            "reason": reason,
            "turn": self.turn,
            "scores": {"ai1": self.board1.score, "ai2": self.board2.score},
            "lines": {"ai1": self.board1.lines_cleared, "ai2": self.board2.lines_cleared},
        }

    def _winner_by_score(self) -> str:
        if self.board1.score == self.board2.score:
            if self.board1.lines_cleared >= self.board2.lines_cleared:
                return self.ai1.name
            return self.ai2.name
        if self.board1.score > self.board2.score:
            return self.ai1.name
        return self.ai2.name

    def step(self):
        if self.turn >= self.max_turns:
            winner = self._winner_by_score()
            return self._result_state(True, winner, "turn_limit")
        self.turn += 1
        if self.garbage_queue_ai1:
            self.board1.add_garbage_lines(self.garbage_queue_ai1)
            self.garbage_queue_ai1 = 0
        lines1, _, attack1 = self.play_turn(self.ai1, self.board1, self.current_piece_ai1)
        if self.board1.game_over or self.board1.is_game_over():
            return self._result_state(True, self.ai2.name, "ai1_board_overflow")
        if lines1 > 0:
            self.garbage_queue_ai2 += lines1
        if attack1 and self.bank.is_available(attack1):
            self.current_piece_ai1 = attack1
            self.bank.get_piece(attack1)
        else:
            self.current_piece_ai1 = self._get_next_piece()
        if self.garbage_queue_ai2:
            self.board2.add_garbage_lines(self.garbage_queue_ai2)
            self.garbage_queue_ai2 = 0
        lines2, _, attack2 = self.play_turn(self.ai2, self.board2, self.current_piece_ai2)
        if self.board2.game_over or self.board2.is_game_over():
            return self._result_state(True, self.ai1.name, "ai2_board_overflow")
        if lines2 > 0:
            self.garbage_queue_ai1 += lines2
        if attack2 and self.bank.is_available(attack2):
            self.current_piece_ai2 = attack2
            self.bank.get_piece(attack2)
        else:
            self.current_piece_ai2 = self._get_next_piece()
        if self.turn >= self.max_turns:
            winner = self._winner_by_score()
            return self._result_state(True, winner, "turn_limit")
        return self._result_state(False, None, "ongoing")


# --- UI helpers --------------------------------------------------------------

def board_text(board: GameBoard) -> str:
    return board.to_string()


def bank_text(bank: FigureBank) -> str:
    lines = ["FIGURE BANK"]
    state = bank.get_state()
    for piece in TETROMINO_TYPES:
        count = state[piece]
        lines.append(f"{piece}: {count:02d}")
    total = sum(state.values())
    lines.append(f"Total: {total}")
    return "\n".join(lines)


# --- UI State Management -----------------------------------------------------

class MatchController:
    def __init__(self):
        self.arena = None
        self.is_running = False
        self.is_paused = False
        self.current_task = None
        
    def update_ui(self):
        board1_element.textContent = board_text(self.arena.board1) if self.arena else ""
        board2_element.textContent = board_text(self.arena.board2) if self.arena else ""
        bank_element.textContent = bank_text(self.arena.bank) if self.arena else ""
        
    def update_status(self, state):
        ai1_name = self.arena.ai1.name if self.arena else "AI-1"
        ai2_name = self.arena.ai2.name if self.arena else "AI-2"
        status_element.textContent = (
            f"Turn {state['turn']} | Score {ai1_name}: {state['scores']['ai1']} | "
            f"Score {ai2_name}: {state['scores']['ai2']}"
        )
        if state["finished"]:
            status_element.textContent += (
                f" | Winner: {state['winner']} (reason: {state['reason']})"
            )
    
    def update_buttons(self, running=None, paused=None, finished=False):
        if running is not None:
            self.is_running = running
        if paused is not None:
            self.is_paused = paused
            
        start_button.disabled = self.is_running
        pause_button.disabled = not self.is_running or self.is_paused or finished
        resume_button.disabled = not self.is_paused or finished
        step_button.disabled = not self.is_paused or finished
        restart_button.disabled = not self.is_running and not finished

controller = MatchController()

start_button = document.getElementById("start")
pause_button = document.getElementById("pause")
resume_button = document.getElementById("resume")
step_button = document.getElementById("step")
restart_button = document.getElementById("restart")
status_element = document.getElementById("status")
board1_element = document.getElementById("board1")
board2_element = document.getElementById("board2")
bank_element = document.getElementById("bank")
ai1_name_element = document.getElementById("ai1-name")
ai2_name_element = document.getElementById("ai2-name")
speed_slider = document.getElementById("speed")
speed_value = document.getElementById("speed-value")


def update_speed_label(event=None):
    speed_value.textContent = f"{speed_slider.value} ms"


async def run_match(event=None):
    if controller.is_running:
        return
    controller.is_running = True
    controller.is_paused = False
    controller.update_buttons()
    
    bank = FigureBank(initial_count=12)
    ai1 = AIAgent("AI-1", strategy="greedy")
    ai2 = AIAgent("AI-2", strategy="aggressive")
    controller.arena = Arena(ai1, ai2, bank, max_turns=320)
    
    ai1_name_element.textContent = ai1.name
    ai2_name_element.textContent = ai2.name
    status_element.textContent = "Match in progress..."
    
    while controller.is_running:
        if controller.is_paused:
            await asyncio.sleep(0.1)
            continue
            
        state = controller.arena.step()
        controller.update_ui()
        controller.update_status(state)
        
        if state["finished"]:
            controller.is_running = False
            controller.update_buttons(finished=True)
            break
            
        delay = max(int(speed_slider.value), 50) / 1000.0
        await asyncio.sleep(delay)


def pause_match(event=None):
    controller.is_paused = True
    controller.update_buttons(paused=True)


def resume_match(event=None):
    controller.is_paused = False
    controller.update_buttons(paused=False)


async def step_match(event=None):
    if not controller.is_paused or not controller.arena:
        return
    state = controller.arena.step()
    controller.update_ui()
    controller.update_status(state)
    if state["finished"]:
        controller.update_buttons(finished=True)


def restart_match(event=None):
    controller.is_running = False
    controller.is_paused = False
    controller.arena = None
    controller.update_buttons()
    board1_element.textContent = ""
    board2_element.textContent = ""
    bank_element.textContent = ""
    status_element.textContent = "Press 'Start Match' to begin a new simulation."


start_handler = create_proxy(lambda e: asyncio.ensure_future(run_match(e)))
pause_handler = create_proxy(pause_match)
resume_handler = create_proxy(resume_match)
step_handler = create_proxy(lambda e: asyncio.ensure_future(step_match(e)))
restart_handler = create_proxy(restart_match)
speed_handler = create_proxy(update_speed_label)

start_button.addEventListener("click", start_handler)
pause_button.addEventListener("click", pause_handler)
resume_button.addEventListener("click", resume_handler)
step_button.addEventListener("click", step_handler)
restart_button.addEventListener("click", restart_handler)
speed_slider.addEventListener("input", speed_handler)

controller.update_buttons()
update_speed_label()


# --- Tournament Mode ---------------------------------------------------------

tournament_results = []
start_tournament_button = document.getElementById("start-tournament")
clear_tournament_button = document.getElementById("clear-tournament")
num_matches_input = document.getElementById("num-matches")
tournament_results_div = document.getElementById("tournament-results")
tournament_tbody = document.getElementById("tournament-tbody")
tournament_summary = document.getElementById("tournament-summary")


async def run_tournament(event=None):
    global tournament_results
    if controller.is_running:
        return
    
    num_matches = int(num_matches_input.value)
    if num_matches < 1 or num_matches > 50:
        status_element.textContent = "Please enter 1-50 matches"
        return
    
    start_tournament_button.disabled = True
    clear_tournament_button.disabled = True
    start_button.disabled = True
    status_element.textContent = f"Running tournament: 0/{num_matches} matches completed..."
    
    for match_num in range(1, num_matches + 1):
        bank = FigureBank(initial_count=12)
        ai1 = AIAgent("AI-1", strategy="greedy")
        ai2 = AIAgent("AI-2", strategy="aggressive")
        arena = Arena(ai1, ai2, bank, max_turns=320)
        
        state = None
        while True:
            state = arena.step()
            if state["finished"]:
                break
            await asyncio.sleep(0.001)
        
        tournament_results.append({
            "match": match_num,
            "winner": state["winner"],
            "ai1_score": state["scores"]["ai1"],
            "ai2_score": state["scores"]["ai2"],
            "turns": state["turn"],
            "reason": state["reason"]
        })
        
        status_element.textContent = f"Running tournament: {match_num}/{num_matches} matches completed..."
        await asyncio.sleep(0.05)
    
    display_tournament_results()
    start_tournament_button.disabled = False
    clear_tournament_button.disabled = False
    start_button.disabled = False
    status_element.textContent = f"Tournament complete! {num_matches} matches finished."


def display_tournament_results():
    global tournament_results
    if not tournament_results:
        return
    
    tournament_tbody.innerHTML = ""
    for result in tournament_results:
        row = document.createElement("tr")
        row.innerHTML = f"""
            <td>{result['match']}</td>
            <td><strong>{result['winner']}</strong></td>
            <td>{result['ai1_score']}</td>
            <td>{result['ai2_score']}</td>
            <td>{result['turns']}</td>
            <td>{result['reason']}</td>
        """
        tournament_tbody.appendChild(row)
    
    ai1_wins = sum(1 for r in tournament_results if r["winner"] == "AI-1")
    ai2_wins = sum(1 for r in tournament_results if r["winner"] == "AI-2")
    total = len(tournament_results)
    avg_ai1_score = sum(r["ai1_score"] for r in tournament_results) / total
    avg_ai2_score = sum(r["ai2_score"] for r in tournament_results) / total
    avg_turns = sum(r["turns"] for r in tournament_results) / total
    
    tournament_summary.innerHTML = f"""
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 8px;">
            <div>
                <strong>AI-1 Wins:</strong> {ai1_wins}/{total} ({ai1_wins*100/total:.1f}%)<br/>
                <strong>Avg Score:</strong> {avg_ai1_score:.0f}
            </div>
            <div>
                <strong>AI-2 Wins:</strong> {ai2_wins}/{total} ({ai2_wins*100/total:.1f}%)<br/>
                <strong>Avg Score:</strong> {avg_ai2_score:.0f}
            </div>
            <div>
                <strong>Avg Turns:</strong> {avg_turns:.1f}<br/>
                <strong>Total Matches:</strong> {total}
            </div>
        </div>
    """
    
    tournament_results_div.classList.add("visible")


def clear_tournament_results(event=None):
    global tournament_results
    tournament_results = []
    tournament_tbody.innerHTML = ""
    tournament_summary.innerHTML = ""
    tournament_results_div.classList.remove("visible")
    status_element.textContent = "Tournament results cleared."


tournament_handler = create_proxy(lambda e: asyncio.ensure_future(run_tournament(e)))
clear_handler = create_proxy(clear_tournament_results)
start_tournament_button.addEventListener("click", tournament_handler)
clear_tournament_button.addEventListener("click", clear_handler)
</py-script>
</body>
</html>
