<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>AI vs AI Tetris (PyScript)</title>
<link rel="stylesheet" href="https://pyscript.net/releases/2024.11.1/core.css" />
<script type="module" src="https://pyscript.net/releases/2024.11.1/core.js"></script>
<style>
body {
  font-family: Arial, sans-serif;
  background-color: #111;
  color: #e2e2e2;
  margin: 0;
  padding: 32px 24px;
}

h1 {
  margin-top: 0;
  letter-spacing: 1px;
}

#controls {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 16px;
}

button {
  padding: 8px 16px;
  background-color: #1e88e5;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.95rem;
}

button:hover:not(:disabled) {
  background-color: #1976d2;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.secondary {
  background-color: #424242;
}

button.secondary:hover:not(:disabled) {
  background-color: #616161;
}

button.danger {
  background-color: #d32f2f;
}

button.danger:hover:not(:disabled) {
  background-color: #c62828;
}

label {
  font-size: 0.9rem;
}

input[type="range"] {
  width: 160px;
}

#status {
  margin: 12px 0 24px 0;
  font-size: 1rem;
}

.boards {
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
}

.board {
  min-width: 240px;
}

.board h2 {
  margin-bottom: 8px;
  font-size: 1.1rem;
}

pre {
  background-color: #000;
  color: #39ff14;
  padding: 12px;
  line-height: 1.1;
  border-radius: 4px;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.15);
  overflow-x: auto;
}

canvas {
  border: 2px solid #39ff14;
  border-radius: 4px;
  background-color: #000;
  box-shadow: 0 0 16px rgba(0, 255, 0, 0.2);
}

.bank-section {
  margin-top: 24px;
  padding: 16px;
  background-color: #1a1a1a;
  border-radius: 8px;
}

.bank-section h2 {
  margin-top: 0;
  margin-bottom: 12px;
}

.view-toggle {
  margin-bottom: 12px;
}

.view-toggle button {
  padding: 4px 12px;
  font-size: 0.85rem;
}

#bank {
  margin-top: 24px;
}

.stats-section {
  margin-top: 24px;
  padding: 16px;
  background-color: #1a1a1a;
  border-radius: 8px;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-top: 12px;
}

.stat-card {
  padding: 12px;
  background-color: #2a2a2a;
  border-radius: 4px;
  border-left: 3px solid #1e88e5;
}

.stat-card h4 {
  margin: 0 0 8px 0;
  font-size: 0.9rem;
  color: #aaa;
}

.stat-card .value {
  font-size: 1.5rem;
  font-weight: 600;
  color: #39ff14;
}

footer {
  margin-top: 36px;
  font-size: 0.8rem;
  color: #8c8c8c;
}

.tournament-section {
  margin-top: 32px;
  padding: 20px;
  background-color: #1a1a1a;
  border-radius: 8px;
}

.tournament-section h2 {
  margin-top: 0;
  margin-bottom: 16px;
}

.tournament-controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.tournament-controls label {
  font-size: 0.9rem;
}

.tournament-controls input[type="number"] {
  width: 60px;
  padding: 4px 8px;
  background-color: #2a2a2a;
  color: #e2e2e2;
  border: 1px solid #444;
  border-radius: 4px;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
}

table th, table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #333;
}

table th {
  background-color: #2a2a2a;
  font-weight: 600;
}

table tr:hover {
  background-color: #252525;
}

#tournament-results {
  display: none;
}

#tournament-results.visible {
  display: block;
}
</style>
</head>
<body>
<h1>AI vs AI Tetris (PyScript)</h1>
<div style="display: flex; gap: 32px; margin-bottom: 16px; flex-wrap: wrap;">
  <div>
    <label style="display: block; margin-bottom: 4px; font-weight: 600;">AI-1 Strategy:</label>
    <select id="ai1-strategy" style="padding: 6px 12px; background-color: #2a2a2a; color: #e2e2e2; border: 1px solid #444; border-radius: 4px;">
      <option value="greedy">Greedy (Balanced)</option>
      <option value="aggressive">Aggressive (Line Clears)</option>
      <option value="defensive">Defensive (Safe Play)</option>
    </select>
  </div>
  <div>
    <label style="display: block; margin-bottom: 4px; font-weight: 600;">AI-2 Strategy:</label>
    <select id="ai2-strategy" style="padding: 6px 12px; background-color: #2a2a2a; color: #e2e2e2; border: 1px solid #444; border-radius: 4px;">
      <option value="greedy">Greedy (Balanced)</option>
      <option value="aggressive" selected>Aggressive (Line Clears)</option>
      <option value="defensive">Defensive (Safe Play)</option>
    </select>
  </div>
</div>
<div id="controls">
  <button id="start">‚ñ∂Ô∏è Start Match</button>
  <button id="pause" disabled>‚è∏Ô∏è Pause</button>
  <button id="resume" disabled>‚ñ∂Ô∏è Resume</button>
  <button id="step" disabled>‚è≠Ô∏è Step</button>
  <button id="restart" class="secondary" disabled>üîÑ Restart</button>
  <button id="export-replay" class="secondary" disabled>üíæ Export Replay</button>
  <label for="speed">Speed:</label>
  <input id="speed" type="range" min="50" max="600" value="150" step="10" />
  <span id="speed-value">150 ms</span>
</div>
<div id="status">Press "Start Match" to begin the simulation. <span style="color: #808080; font-weight: bold;">Gray blocks (‚ñà)</span> are garbage lines sent by clearing multiple lines.</div>
<div class="view-toggle">
  <button id="view-ascii" class="secondary">üìù ASCII View</button>
  <button id="view-canvas">üé® Canvas View</button>
</div>
<div class="boards">
  <div class="board">
    <h2 id="ai1-name">AI-1</h2>
    <canvas id="canvas1" width="200" height="400" style="display: none;"></canvas>
    <pre id="board1"></pre>
  </div>
  <div class="board">
    <h2 id="ai2-name">AI-2</h2>
    <canvas id="canvas2" width="200" height="400" style="display: none;"></canvas>
    <pre id="board2"></pre>
  </div>
</div>

<div class="bank-section">
  <h2>üé≤ Figure Bank</h2>
  <canvas id="bank-canvas" width="420" height="150" style="display: none;"></canvas>
  <pre id="bank"></pre>
</div>

<div class="stats-section" id="stats-section" style="display: none;">
  <h2>üìä Match Statistics</h2>
  <div class="stats-grid" id="stats-grid"></div>
</div>

<div class="tournament-section">
  <h2>üèÜ Tournament Mode</h2>
  <div class="tournament-controls">
    <label for="num-matches">Number of matches:</label>
    <input id="num-matches" type="number" min="1" max="50" value="5" />
    <button id="start-tournament">üéØ Run Tournament</button>
    <button id="clear-tournament" class="secondary">üóëÔ∏è Clear Results</button>
  </div>
  <div id="tournament-results">
    <h3>Results</h3>
    <table id="tournament-table">
      <thead>
        <tr>
          <th>Match #</th>
          <th>Winner</th>
          <th>AI-1 Score</th>
          <th>AI-2 Score</th>
          <th>Turns</th>
          <th>Reason</th>
        </tr>
      </thead>
      <tbody id="tournament-tbody"></tbody>
    </table>
    <div style="margin-top: 16px; padding: 12px; background-color: #2a2a2a; border-radius: 4px;">
      <strong>Summary:</strong>
      <div id="tournament-summary"></div>
    </div>
  </div>
</div>

<footer>
  Powered by PyScript. Runs entirely in the browser without servers or binaries.
</footer>
<py-config>
  packages = []
</py-config>
<py-script>
import asyncio
import random
import time
from js import document
from pyodide.ffi import create_proxy

# --- Core data structures ----------------------------------------------------

SHAPES = {
    "I": [[1, 1, 1, 1]],
    "O": [[1, 1], [1, 1]],
    "T": [[0, 1, 0], [1, 1, 1]],
    "S": [[0, 1, 1], [1, 1, 0]],
    "Z": [[1, 1, 0], [0, 1, 1]],
    "L": [[1, 0], [1, 0], [1, 1]],
    "J": [[0, 1], [0, 1], [1, 1]],
}

# Classic Tetris colors (The Tetris Company standard)
COLORS = {
    "I": "#00f0f0",  # Cyan
    "O": "#f0f000",  # Yellow
    "T": "#a000f0",  # Purple
    "S": "#00f000",  # Green
    "Z": "#f00000",  # Red
    "L": "#f0a000",  # Orange
    "J": "#0000f0",  # Blue
}

TETROMINO_TYPES = list(SHAPES.keys())


def clone_shape(shape):
    return [row[:] for row in shape]


class Tetromino:
    def __init__(self, shape_type: str):
        self.type = shape_type
        self.shape = clone_shape(SHAPES[shape_type])
        self.rotation = 0

    def rotate(self):
        rotated = [list(row) for row in zip(*self.shape[::-1])]
        self.shape = rotated
        self.rotation = (self.rotation + 1) % 4

    def get_width(self):
        return len(self.shape[0]) if self.shape else 0

    def get_height(self):
        return len(self.shape)


class GameBoard:
    def __init__(self, width: int = 10, height: int = 20):
        self.width = width
        self.height = height
        self.grid = [[None for _ in range(width)] for _ in range(height)]
        self.score = 0
        self.lines_cleared = 0
        self.game_over = False

    def can_place(self, piece: Tetromino, x: int, y: int) -> bool:
        for row_idx, row in enumerate(piece.shape):
            for col_idx, cell in enumerate(row):
                if not cell:
                    continue
                board_y = y + row_idx
                board_x = x + col_idx
                if board_x < 0 or board_x >= self.width:
                    return False
                if board_y < 0 or board_y >= self.height:
                    return False
                if self.grid[board_y][board_x]:
                    return False
        return True

    def place_piece(self, piece: Tetromino, x: int, y: int):
        for row_idx, row in enumerate(piece.shape):
            for col_idx, cell in enumerate(row):
                if cell:
                    board_y = y + row_idx
                    board_x = x + col_idx
                    if 0 <= board_y < self.height and 0 <= board_x < self.width:
                        self.grid[board_y][board_x] = piece.type

    def clear_lines(self) -> int:
        completed = [index for index, row in enumerate(self.grid) if all(row)]
        for idx in completed:
            del self.grid[idx]
            self.grid.insert(0, [None for _ in range(self.width)])
        cleared = len(completed)
        if cleared:
            self.lines_cleared += cleared
            score_table = {1: 100, 2: 300, 3: 500, 4: 800}
            self.score += score_table.get(cleared, cleared * 100)
        return cleared

    def add_garbage_lines(self, num_lines: int):
        for _ in range(num_lines):
            self.grid.pop(0)
            garbage = ['G' for _ in range(self.width)]
            hole = random.randint(0, self.width - 1)
            garbage[hole] = None
            self.grid.append(garbage)

    def is_game_over(self) -> bool:
        return any(self.grid[0])

    def get_height_map(self):
        heights = []
        for x in range(self.width):
            column_height = 0
            for y in range(self.height):
                if self.grid[y][x]:
                    column_height = self.height - y
                    break
            heights.append(column_height)
        return heights

    def get_max_height(self):
        heights = self.get_height_map()
        return max(heights) if heights else 0

    def to_string(self) -> str:
        """Generate ASCII board with HTML color styling."""
        lines = ["+" + "-" * self.width + "+"]
        for row in self.grid:
            line = "|"
            for cell in row:
                if cell:
                    if cell == 'G':
                        # Gray for garbage
                        line += f'<span style="color: #808080; font-weight: bold;">‚ñà</span>'
                    else:
                        # Colored block for each piece type
                        color = COLORS.get(cell, "#39ff14")
                        line += f'<span style="color: {color}; font-weight: bold;">‚ñà</span>'
                else:
                    line += " "
            line += "|"
            lines.append(line)
        lines.append("+" + "-" * self.width + "+")
        return "\n".join(lines)


class FigureBank:
    def __init__(self, initial_count: int = 15):
        self.bank = {piece: initial_count for piece in TETROMINO_TYPES}

    def get_piece(self, piece_type: str) -> bool:
        if piece_type not in self.bank:
            return False
        if self.bank[piece_type] > 0:
            self.bank[piece_type] -= 1
            return True
        return False

    def is_available(self, piece_type: str) -> bool:
        return piece_type in self.bank and self.bank[piece_type] > 0

    def get_available_pieces(self):
        return [piece for piece in TETROMINO_TYPES if self.bank[piece] > 0]

    def is_empty(self) -> bool:
        return all(count == 0 for count in self.bank.values())

    def get_random_available(self) -> str | None:
        available = self.get_available_pieces()
        if available:
            return random.choice(available)
        return None

    def get_state(self):
        return self.bank.copy()


class AIAgent:
    def __init__(self, name: str, strategy: str = "greedy"):
        self.name = name
        self.strategy = strategy
        self.decision_times = []

    def decide_placement(self, board: GameBoard, piece: Tetromino):
        start_time = time.time()
        best_position = None
        best_score = float("-inf")
        for rotation in range(4):
            piece_copy = Tetromino(piece.type)
            for _ in range(rotation):
                piece_copy.rotate()
            for x in range(board.width - piece_copy.get_width() + 1):
                y = 0
                while y < board.height and board.can_place(piece_copy, x, y):
                    y += 1
                y -= 1
                if y >= 0 and board.can_place(piece_copy, x, y):
                    score = self._evaluate_position(board, piece_copy, x, y)
                    if score > best_score:
                        best_score = score
                        best_position = (x, y, rotation)
        decision_time = time.time() - start_time
        self.decision_times.append(decision_time)
        if best_position:
            return best_position
        return (board.width // 2, 0, 0)

    def _evaluate_position(self, board: GameBoard, piece: Tetromino, x: int, y: int) -> float:
        test_board = GameBoard(board.width, board.height)
        test_board.grid = [row[:] for row in board.grid]
        test_board.place_piece(piece, x, y)
        max_height = test_board.get_max_height()
        heights = test_board.get_height_map()
        bumpiness = sum(abs(heights[i] - heights[i + 1]) for i in range(len(heights) - 1))
        holes = 0
        for col_x in range(board.width):
            found_block = False
            for row_y in range(board.height):
                if test_board.grid[row_y][col_x]:
                    found_block = True
                elif found_block:
                    holes += 1
        if self.strategy == "greedy":
            score = -max_height * 2 - holes * 5 - bumpiness
        elif self.strategy == "defensive":
            score = -max_height * 3 - holes * 10 - bumpiness * 2
        elif self.strategy == "aggressive":
            lines_cleared = self._count_potential_lines(test_board)
            score = lines_cleared * 100 - max_height - holes * 3
        else:
            score = -max_height - holes
        return score

    def _count_potential_lines(self, board: GameBoard) -> int:
        return sum(1 for row in board.grid if all(row))

    def choose_attack_piece(self, bank: FigureBank):
        available = bank.get_available_pieces()
        if not available:
            return None
        if self.strategy == "aggressive":
            difficult = [p for p in ["T", "L", "J"] if p in available]
            if difficult:
                return random.choice(difficult)
        elif self.strategy == "defensive":
            easy = [p for p in ["I", "O"] if p in available]
            if easy:
                return random.choice(easy)
        return random.choice(available)


class Arena:
    def __init__(self, ai1: AIAgent, ai2: AIAgent, bank: FigureBank, max_turns: int = 360):
        self.ai1 = ai1
        self.ai2 = ai2
        self.board1 = GameBoard()
        self.board2 = GameBoard()
        self.bank = bank
        self.max_turns = max_turns
        self.turn = 0
        self.current_piece_ai1 = self._get_next_piece()
        self.current_piece_ai2 = self._get_next_piece()
        self.garbage_queue_ai1 = 0
        self.garbage_queue_ai2 = 0

    def _get_next_piece(self) -> str:
        piece_type = self.bank.get_random_available()
        if piece_type:
            self.bank.get_piece(piece_type)
            return piece_type
        return random.choice(TETROMINO_TYPES)

    def play_turn(self, ai: AIAgent, board: GameBoard, piece_type: str):
        piece = Tetromino(piece_type)
        x, y, rotations = ai.decide_placement(board, piece)
        for _ in range(rotations):
            piece.rotate()
        if board.can_place(piece, x, y):
            board.place_piece(piece, x, y)
        else:
            board.game_over = True
            return 0, 0.0, None
        lines_cleared = board.clear_lines()
        attack_piece = None
        if lines_cleared > 0:
            attack_piece = ai.choose_attack_piece(self.bank)
        decision_time = ai.decision_times[-1] if ai.decision_times else 0.0
        return lines_cleared, decision_time, attack_piece

    def _result_state(self, finished: bool, winner: str | None, reason: str):
        return {
            "finished": finished,
            "winner": winner,
            "reason": reason,
            "turn": self.turn,
            "scores": {"ai1": self.board1.score, "ai2": self.board2.score},
            "lines": {"ai1": self.board1.lines_cleared, "ai2": self.board2.lines_cleared},
        }

    def _winner_by_score(self) -> str:
        if self.board1.score == self.board2.score:
            if self.board1.lines_cleared >= self.board2.lines_cleared:
                return self.ai1.name
            return self.ai2.name
        if self.board1.score > self.board2.score:
            return self.ai1.name
        return self.ai2.name

    def step(self):
        if self.turn >= self.max_turns:
            winner = self._winner_by_score()
            return self._result_state(True, winner, "turn_limit")
        self.turn += 1
        if self.garbage_queue_ai1:
            self.board1.add_garbage_lines(self.garbage_queue_ai1)
            self.garbage_queue_ai1 = 0
        lines1, _, attack1 = self.play_turn(self.ai1, self.board1, self.current_piece_ai1)
        if self.board1.game_over or self.board1.is_game_over():
            return self._result_state(True, self.ai2.name, "ai1_board_overflow")
        if lines1 > 0:
            self.garbage_queue_ai2 += lines1
        if attack1 and self.bank.is_available(attack1):
            self.current_piece_ai1 = attack1
            self.bank.get_piece(attack1)
        else:
            self.current_piece_ai1 = self._get_next_piece()
        if self.garbage_queue_ai2:
            self.board2.add_garbage_lines(self.garbage_queue_ai2)
            self.garbage_queue_ai2 = 0
        lines2, _, attack2 = self.play_turn(self.ai2, self.board2, self.current_piece_ai2)
        if self.board2.game_over or self.board2.is_game_over():
            return self._result_state(True, self.ai1.name, "ai2_board_overflow")
        if lines2 > 0:
            self.garbage_queue_ai1 += lines2
        if attack2 and self.bank.is_available(attack2):
            self.current_piece_ai2 = attack2
            self.bank.get_piece(attack2)
        else:
            self.current_piece_ai2 = self._get_next_piece()
        if self.turn >= self.max_turns:
            winner = self._winner_by_score()
            return self._result_state(True, winner, "turn_limit")
        return self._result_state(False, None, "ongoing")


# --- UI helpers --------------------------------------------------------------

def board_text(board: GameBoard) -> str:
    return board.to_string()


def bank_text(bank: FigureBank) -> str:
    """Generate ASCII bank display with colored piece indicators."""
    lines = ["<span style='color: #39ff14; font-weight: bold;'>üé≤ FIGURE BANK</span>"]
    state = bank.get_state()
    for piece in TETROMINO_TYPES:
        count = state[piece]
        color = COLORS.get(piece, "#39ff14")
        # Color the piece letter in its signature color
        colored_piece = f'<span style="color: {color}; font-weight: bold;">{piece}</span>'
        # Dim the count if low
        if count <= 2:
            count_style = 'color: #ff3b30; font-weight: bold;'  # Red for critical
        elif count <= 5:
            count_style = 'color: #ff9500; font-weight: bold;'  # Orange for low
        else:
            count_style = 'color: #e2e2e2;'  # Normal
        lines.append(f"{colored_piece}: <span style='{count_style}'>{count:02d}</span>")
    total = sum(state.values())
    lines.append(f"<span style='color: #39ff14;'>Total: {total}</span>")
    return "\n".join(lines)


# --- Canvas Rendering --------------------------------------------------------

def draw_board_canvas(ctx, board: GameBoard):
    """Draw the game board on a canvas with colored pieces."""
    cell_size = 20
    ctx.fillStyle = "#000000"
    ctx.fillRect(0, 0, 200, 400)
    
    for y in range(board.height):
        for x in range(board.width):
            cell = board.grid[y][x]
            if cell:
                # Use piece-specific color, or gray for garbage
                if cell == 'G':
                    ctx.fillStyle = "#808080"  # Gray for garbage
                else:
                    ctx.fillStyle = COLORS.get(cell, "#39ff14")
                
                ctx.fillRect(x * cell_size, y * cell_size, cell_size, cell_size)
                
                # Draw border with slight highlight effect
                ctx.strokeStyle = "#000000"
                ctx.lineWidth = 2
                ctx.strokeRect(x * cell_size, y * cell_size, cell_size, cell_size)
                
                # Inner highlight for 3D effect
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"
                ctx.lineWidth = 1
                ctx.strokeRect(x * cell_size + 2, y * cell_size + 2, cell_size - 4, cell_size - 4)


def draw_bank_canvas(ctx, bank: FigureBank):
    """Draw the figure bank on a canvas."""
    ctx.fillStyle = "#000000"
    ctx.fillRect(0, 0, 420, 150)
    
    state = bank.get_state()
    pieces = list(TETROMINO_TYPES)
    
    bar_width = 50
    bar_gap = 10
    max_height = 100
    max_count = 15
    y_baseline = 130
    
    for i, piece_type in enumerate(pieces):
        x = 10 + i * (bar_width + bar_gap)
        count = state[piece_type]
        bar_height = (count / max_count) * max_height if max_count > 0 else 0
        
        # Draw bar with piece color (dimmed if low count)
        base_color = COLORS.get(piece_type, "#39ff14")
        if count <= 2:
            # Red tint for critically low
            ctx.fillStyle = "#ff3b30"
        elif count <= 5:
            # Orange tint for low
            ctx.fillStyle = "#ff9500"
        else:
            # Use piece's natural color
            ctx.fillStyle = base_color
        
        ctx.fillRect(x, y_baseline - bar_height, bar_width, bar_height)
        
        # Draw border
        ctx.strokeStyle = "#000000"
        ctx.lineWidth = 2
        ctx.strokeRect(x, y_baseline - bar_height, bar_width, bar_height)
        
        # Draw piece type label with its color
        ctx.fillStyle = base_color
        ctx.font = "bold 16px monospace"
        ctx.textAlign = "center"
        ctx.fillText(piece_type, x + bar_width / 2, y_baseline + 18)
        
        # Draw count
        ctx.fillStyle = "#ffffff"
        ctx.font = "bold 14px monospace"
        ctx.fillText(str(count), x + bar_width / 2, y_baseline - bar_height - 8)


# --- UI State Management -----------------------------------------------------

class MatchController:
    def __init__(self):
        self.arena = None
        self.is_running = False
        self.is_paused = False
        self.current_task = None
        self.match_stats = {
            "turns": [],
            "ai1_scores": [],
            "ai2_scores": [],
            "ai1_lines": [],
            "ai2_lines": [],
        }
        
    def update_ui(self):
        if self.arena:
            if use_canvas_view:
                draw_board_canvas(ctx1, self.arena.board1)
                draw_board_canvas(ctx2, self.arena.board2)
                draw_bank_canvas(ctx_bank, self.arena.bank)
            else:
                # Use innerHTML to render HTML color tags
                board1_element.innerHTML = board_text(self.arena.board1)
                board2_element.innerHTML = board_text(self.arena.board2)
                bank_element.innerHTML = bank_text(self.arena.bank)
        else:
            board1_element.innerHTML = ""
            board2_element.innerHTML = ""
            bank_element.innerHTML = ""
        
    def update_status(self, state):
        ai1_name = self.arena.ai1.name if self.arena else "AI-1"
        ai2_name = self.arena.ai2.name if self.arena else "AI-2"
        status_element.textContent = (
            f"Turn {state['turn']} | Score {ai1_name}: {state['scores']['ai1']} | "
            f"Score {ai2_name}: {state['scores']['ai2']}"
        )
        if state["finished"]:
            status_element.textContent += (
                f" | Winner: {state['winner']} (reason: {state['reason']})"
            )
    
    def collect_stats(self, state):
        self.match_stats["turns"].append(state["turn"])
        self.match_stats["ai1_scores"].append(state["scores"]["ai1"])
        self.match_stats["ai2_scores"].append(state["scores"]["ai2"])
        self.match_stats["ai1_lines"].append(state["lines"]["ai1"])
        self.match_stats["ai2_lines"].append(state["lines"]["ai2"])
    
    def display_stats(self):
        if not self.arena:
            return
        
        ai1_avg_time = self.arena.ai1.get_average_decision_time() * 1000
        ai2_avg_time = self.arena.ai2.get_average_decision_time() * 1000
        
        stats_grid.innerHTML = f"""
            <div class="stat-card">
                <h4>AI-1 Final Score</h4>
                <div class="value">{self.arena.board1.score}</div>
            </div>
            <div class="stat-card">
                <h4>AI-2 Final Score</h4>
                <div class="value">{self.arena.board2.score}</div>
            </div>
            <div class="stat-card">
                <h4>AI-1 Lines Cleared</h4>
                <div class="value">{self.arena.board1.lines_cleared}</div>
            </div>
            <div class="stat-card">
                <h4>AI-2 Lines Cleared</h4>
                <div class="value">{self.arena.board2.lines_cleared}</div>
            </div>
            <div class="stat-card">
                <h4>AI-1 Avg Decision Time</h4>
                <div class="value">{ai1_avg_time:.1f} ms</div>
            </div>
            <div class="stat-card">
                <h4>AI-2 Avg Decision Time</h4>
                <div class="value">{ai2_avg_time:.1f} ms</div>
            </div>
            <div class="stat-card">
                <h4>Total Turns</h4>
                <div class="value">{self.arena.turn}</div>
            </div>
            <div class="stat-card">
                <h4>Bank Pieces Remaining</h4>
                <div class="value">{self.arena.bank.get_total_remaining()}</div>
            </div>
        """
        stats_section.style.display = "block"
    
    def update_buttons(self, running=None, paused=None, finished=False):
        if running is not None:
            self.is_running = running
        if paused is not None:
            self.is_paused = paused
            
        start_button.disabled = self.is_running
        pause_button.disabled = not self.is_running or self.is_paused or finished
        resume_button.disabled = not self.is_paused or finished
        step_button.disabled = not self.is_paused or finished
        restart_button.disabled = not self.is_running and not finished
        export_button.disabled = not finished

controller = MatchController()

start_button = document.getElementById("start")
pause_button = document.getElementById("pause")
resume_button = document.getElementById("resume")
step_button = document.getElementById("step")
restart_button = document.getElementById("restart")
export_button = document.getElementById("export-replay")
status_element = document.getElementById("status")
board1_element = document.getElementById("board1")
board2_element = document.getElementById("board2")
bank_element = document.getElementById("bank")
ai1_name_element = document.getElementById("ai1-name")
ai2_name_element = document.getElementById("ai2-name")
speed_slider = document.getElementById("speed")
speed_value = document.getElementById("speed-value")
ai1_strategy_select = document.getElementById("ai1-strategy")
ai2_strategy_select = document.getElementById("ai2-strategy")
canvas1 = document.getElementById("canvas1")
canvas2 = document.getElementById("canvas2")
bank_canvas = document.getElementById("bank-canvas")
ctx1 = canvas1.getContext("2d")
ctx2 = canvas2.getContext("2d")
ctx_bank = bank_canvas.getContext("2d")
view_ascii_button = document.getElementById("view-ascii")
view_canvas_button = document.getElementById("view-canvas")
stats_section = document.getElementById("stats-section")
stats_grid = document.getElementById("stats-grid")

use_canvas_view = False


def update_speed_label(event=None):
    speed_value.textContent = f"{speed_slider.value} ms"


async def run_match(event=None):
    if controller.is_running:
        return
    controller.is_running = True
    controller.is_paused = False
    controller.update_buttons()
    
    ai1_strategy = ai1_strategy_select.value
    ai2_strategy = ai2_strategy_select.value
    
    bank = FigureBank(initial_count=12)
    ai1 = AIAgent(f"AI-1 ({ai1_strategy.capitalize()})", strategy=ai1_strategy)
    ai2 = AIAgent(f"AI-2 ({ai2_strategy.capitalize()})", strategy=ai2_strategy)
    controller.arena = Arena(ai1, ai2, bank, max_turns=320)
    
    ai1_name_element.textContent = ai1.name
    ai2_name_element.textContent = ai2.name
    status_element.textContent = "Match in progress..."
    
    while controller.is_running:
        if controller.is_paused:
            await asyncio.sleep(0.1)
            continue
            
        state = controller.arena.step()
        controller.update_ui()
        controller.update_status(state)
        controller.collect_stats(state)
        
        if state["finished"]:
            controller.is_running = False
            controller.update_buttons(finished=True)
            controller.display_stats()
            break
            
        delay = max(int(speed_slider.value), 50) / 1000.0
        await asyncio.sleep(delay)


def pause_match(event=None):
    controller.is_paused = True
    controller.update_buttons(paused=True)


def resume_match(event=None):
    controller.is_paused = False
    controller.update_buttons(paused=False)


async def step_match(event=None):
    if not controller.is_paused or not controller.arena:
        return
    state = controller.arena.step()
    controller.update_ui()
    controller.update_status(state)
    if state["finished"]:
        controller.update_buttons(finished=True)


def restart_match(event=None):
    controller.is_running = False
    controller.is_paused = False
    controller.arena = None
    controller.match_stats = {
        "turns": [],
        "ai1_scores": [],
        "ai2_scores": [],
        "ai1_lines": [],
        "ai2_lines": [],
    }
    controller.update_buttons()
    board1_element.textContent = ""
    board2_element.textContent = ""
    bank_element.textContent = ""
    stats_section.style.display = "none"
    status_element.textContent = "Press 'Start Match' to begin a new simulation."


start_handler = create_proxy(lambda e: asyncio.ensure_future(run_match(e)))
pause_handler = create_proxy(pause_match)
resume_handler = create_proxy(resume_match)
step_handler = create_proxy(lambda e: asyncio.ensure_future(step_match(e)))
restart_handler = create_proxy(restart_match)
speed_handler = create_proxy(update_speed_label)

start_button.addEventListener("click", start_handler)
pause_button.addEventListener("click", pause_handler)
resume_button.addEventListener("click", resume_handler)
step_button.addEventListener("click", step_handler)
restart_button.addEventListener("click", restart_handler)
speed_slider.addEventListener("input", speed_handler)

controller.update_buttons()
update_speed_label()


# --- Tournament Mode ---------------------------------------------------------

tournament_results = []
start_tournament_button = document.getElementById("start-tournament")
clear_tournament_button = document.getElementById("clear-tournament")
num_matches_input = document.getElementById("num-matches")
tournament_results_div = document.getElementById("tournament-results")
tournament_tbody = document.getElementById("tournament-tbody")
tournament_summary = document.getElementById("tournament-summary")


async def run_tournament(event=None):
    global tournament_results
    if controller.is_running:
        return
    
    num_matches = int(num_matches_input.value)
    if num_matches < 1 or num_matches > 50:
        status_element.textContent = "Please enter 1-50 matches"
        return
    
    start_tournament_button.disabled = True
    clear_tournament_button.disabled = True
    start_button.disabled = True
    status_element.textContent = f"Running tournament: 0/{num_matches} matches completed..."
    
    ai1_strategy = ai1_strategy_select.value
    ai2_strategy = ai2_strategy_select.value
    
    for match_num in range(1, num_matches + 1):
        bank = FigureBank(initial_count=12)
        ai1 = AIAgent(f"AI-1 ({ai1_strategy.capitalize()})", strategy=ai1_strategy)
        ai2 = AIAgent(f"AI-2 ({ai2_strategy.capitalize()})", strategy=ai2_strategy)
        arena = Arena(ai1, ai2, bank, max_turns=320)
        
        state = None
        while True:
            state = arena.step()
            if state["finished"]:
                break
            await asyncio.sleep(0.001)
        
        tournament_results.append({
            "match": match_num,
            "winner": state["winner"],
            "ai1_score": state["scores"]["ai1"],
            "ai2_score": state["scores"]["ai2"],
            "turns": state["turn"],
            "reason": state["reason"]
        })
        
        status_element.textContent = f"Running tournament: {match_num}/{num_matches} matches completed..."
        await asyncio.sleep(0.05)
    
    display_tournament_results()
    start_tournament_button.disabled = False
    clear_tournament_button.disabled = False
    start_button.disabled = False
    status_element.textContent = f"Tournament complete! {num_matches} matches finished."


def display_tournament_results():
    global tournament_results
    if not tournament_results:
        return
    
    tournament_tbody.innerHTML = ""
    for result in tournament_results:
        row = document.createElement("tr")
        row.innerHTML = f"""
            <td>{result['match']}</td>
            <td><strong>{result['winner']}</strong></td>
            <td>{result['ai1_score']}</td>
            <td>{result['ai2_score']}</td>
            <td>{result['turns']}</td>
            <td>{result['reason']}</td>
        """
        tournament_tbody.appendChild(row)
    
    ai1_wins = sum(1 for r in tournament_results if r["winner"] == "AI-1")
    ai2_wins = sum(1 for r in tournament_results if r["winner"] == "AI-2")
    total = len(tournament_results)
    avg_ai1_score = sum(r["ai1_score"] for r in tournament_results) / total
    avg_ai2_score = sum(r["ai2_score"] for r in tournament_results) / total
    avg_turns = sum(r["turns"] for r in tournament_results) / total
    
    tournament_summary.innerHTML = f"""
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 8px;">
            <div>
                <strong>AI-1 Wins:</strong> {ai1_wins}/{total} ({ai1_wins*100/total:.1f}%)<br/>
                <strong>Avg Score:</strong> {avg_ai1_score:.0f}
            </div>
            <div>
                <strong>AI-2 Wins:</strong> {ai2_wins}/{total} ({ai2_wins*100/total:.1f}%)<br/>
                <strong>Avg Score:</strong> {avg_ai2_score:.0f}
            </div>
            <div>
                <strong>Avg Turns:</strong> {avg_turns:.1f}<br/>
                <strong>Total Matches:</strong> {total}
            </div>
        </div>
    """
    
    tournament_results_div.classList.add("visible")


def clear_tournament_results(event=None):
    global tournament_results
    tournament_results = []
    tournament_tbody.innerHTML = ""
    tournament_summary.innerHTML = ""
    tournament_results_div.classList.remove("visible")
    status_element.textContent = "Tournament results cleared."


tournament_handler = create_proxy(lambda e: asyncio.ensure_future(run_tournament(e)))
clear_handler = create_proxy(clear_tournament_results)
start_tournament_button.addEventListener("click", tournament_handler)
clear_tournament_button.addEventListener("click", clear_handler)


# --- View Toggle -------------------------------------------------------------

def switch_to_ascii(event=None):
    global use_canvas_view
    use_canvas_view = False
    canvas1.style.display = "none"
    canvas2.style.display = "none"
    bank_canvas.style.display = "none"
    board1.style.display = "block"
    board2.style.display = "block"
    bank.style.display = "block"
    view_ascii_button.classList.add("secondary")
    view_canvas_button.classList.remove("secondary")
    if controller.arena:
        controller.update_ui()


def switch_to_canvas(event=None):
    global use_canvas_view
    use_canvas_view = True
    canvas1.style.display = "block"
    canvas2.style.display = "block"
    bank_canvas.style.display = "block"
    board1.style.display = "none"
    board2.style.display = "none"
    bank.style.display = "none"
    view_ascii_button.classList.remove("secondary")
    view_canvas_button.classList.add("secondary")
    if controller.arena:
        controller.update_ui()


ascii_handler = create_proxy(switch_to_ascii)
canvas_handler = create_proxy(switch_to_canvas)
view_ascii_button.addEventListener("click", ascii_handler)
view_canvas_button.addEventListener("click", canvas_handler)


# --- Replay Export -----------------------------------------------------------

def export_replay(event=None):
    if not controller.arena or not controller.match_stats["turns"]:
        return
    
    from js import Date
    timestamp = Date.new().toISOString()
    
    replay_data = {
        "version": "1.0",
        "timestamp": timestamp,
        "match_info": {
            "ai1_name": controller.arena.ai1.name,
            "ai2_name": controller.arena.ai2.name,
            "ai1_strategy": controller.arena.ai1.strategy,
            "ai2_strategy": controller.arena.ai2.strategy,
            "max_turns": controller.arena.max_turns,
        },
        "final_state": {
            "winner": "AI-1" if controller.arena.board1.score > controller.arena.board2.score else "AI-2",
            "ai1_score": controller.arena.board1.score,
            "ai2_score": controller.arena.board2.score,
            "ai1_lines": controller.arena.board1.lines_cleared,
            "ai2_lines": controller.arena.board2.lines_cleared,
            "total_turns": controller.arena.turn,
            "bank_remaining": controller.arena.bank.get_total_remaining(),
        },
        "statistics": {
            "ai1_avg_decision_time_ms": controller.arena.ai1.get_average_decision_time() * 1000,
            "ai2_avg_decision_time_ms": controller.arena.ai2.get_average_decision_time() * 1000,
            "ai1_total_decisions": len(controller.arena.ai1.decision_times),
            "ai2_total_decisions": len(controller.arena.ai2.decision_times),
        },
        "history": {
            "turns": controller.match_stats["turns"],
            "ai1_scores": controller.match_stats["ai1_scores"],
            "ai2_scores": controller.match_stats["ai2_scores"],
            "ai1_lines": controller.match_stats["ai1_lines"],
            "ai2_lines": controller.match_stats["ai2_lines"],
        }
    }
    
    from js import JSON, Blob, URL, document as doc
    json_str = JSON.stringify(replay_data, None, 2)
    blob = Blob.new([json_str], {"type": "application/json"})
    url = URL.createObjectURL(blob)
    
    link = doc.createElement("a")
    link.href = url
    link.download = f"tetris_replay_{timestamp.replace(':', '-').replace('.', '_')}.json"
    link.click()
    
    URL.revokeObjectURL(url)
    status_element.textContent = "Replay exported successfully!"


export_handler = create_proxy(export_replay)
export_button.addEventListener("click", export_handler)
</py-script>
</body>
</html>
